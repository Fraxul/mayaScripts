// Cook a scale factor into a skeleton and its skinned mesh(es).
// Select one or more meshes and the root joint of the skeleton; the scale
// factor is function argument.
// Will also cook any translation/rotation of the root joint of the input
// skeleton into the output, so rotate the root joint first if you also need
// to correct the orientation of the input meshes.
// Does not preserve any other deformers (like blend shapes).

global proc rescaleSkinnedMeshes(float $scale) {
  string $selArr[];
  
  // Enumerate selected mesh-transforms and root of skeleton
  $selArr = `ls -sl -type joint`;
  string $origSkelRoot = $selArr[0];
  select -d $origSkelRoot;
  string $meshes[] = `ls -sl -tr`;
  
  // Duplicate skeleton
  $selArr = `duplicate -rr $origSkelRoot`;
  string $newSkelRoot = $selArr[0];
  
  // Rescale duplicate skeleton
  select -r -hi $newSkelRoot;
  for ($node in `ls -sl -type joint`) {
    scale -pcp 1 1 1 $node; // Reset scale to unity on new joints
    $worldTx = `xform -q -ws -translation $node`;
    move -pcp -absolute -worldSpace ($worldTx[0] * $scale) ($worldTx[1] * $scale) ($worldTx[2] * $scale) $node;

    setAttr ($node + ".radius") (`getAttr ($node + ".radius")` * $scale);
  }
  // Rescale any non-joint transform children of the duplicate skeleton
  // (This covers things like meshes parented into the skeleton hierarchy)
  select -r -hi $newSkelRoot;
  select -d `ls -sl -type joint`;
  string $transforms[] = `ls -sl -type transform`;
  if (size($transforms) > 0) {
    for ($node in $transforms) {
      scale -pcp -relative -ws -pivot 0 0 0 $scale $scale $scale $node;
    }
  }
  
  // Scale original skeleton in prep for mesh duplication
  string $origSkelGroup = `group $origSkelRoot`;
  scale -p 0 0 0 $scale $scale $scale $origSkelGroup;
  
  // Rename root of new skeleton to match name of root of old skeleton.
  // (Should work now because old skeleton is in a group -- no name conflicts)
  $sns = stringToStringArray($origSkelRoot, "|" );
  $sn = $sns[size($sns) -1];
  $newSkelRoot = `rename $newSkelRoot $sn`;
  
  for ($mesh in $meshes) {
    // Create duplicate for binding
    $selArr = `duplicate $mesh`;
    string $newMeshXf = $selArr[0];
    delete -ch $newMeshXf; // ensure history is gone
  
    // Clean up extra intermediate nodes left behind by duplicating a skinned mesh
    delete `ls -io -dag $newMeshXf`;
  
    // Unlock and zero mesh transform
    setAttr -l off ($newMeshXf + ".translateX");
    setAttr -l off ($newMeshXf + ".translateY");
    setAttr -l off ($newMeshXf + ".translateZ");
    setAttr -l off ($newMeshXf + ".rotateX");
    setAttr -l off ($newMeshXf + ".rotateY");
    setAttr -l off ($newMeshXf + ".rotateZ");
    setAttr -l off ($newMeshXf + ".scaleX");
    setAttr -l off ($newMeshXf + ".scaleY");
    setAttr -l off ($newMeshXf + ".scaleZ");
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 -pn 1 $newMeshXf;
  
    // Bind new geometry to new skeleton
    $selArr = `ls -dag -g $newMeshXf`;
    $newMesh = $selArr[0];
    select -r $newSkelRoot $newMesh;
    $selArr = `skinCluster -bm 1 -mi 4 -nw 1 -omi true -sm 1`;
    $destSkinCluster = $selArr[0];
    
    // Find source skin cluster
    $selArr = `ls -dag -g $mesh`;
    $selArr = `listConnections -type skinCluster $selArr`;
    if (size($selArr) == 0) {
      // Slightly more indirect approach, this will end up selecting it through the deformer set
      $selArr = `ls -dag -g $mesh`;
      $selArr = `listConnections -type objectSet $selArr`;
      $selArr = `listConnections -type skinCluster $selArr`;
    }
    if (size($selArr) == 0) {
      warning ("Couldn't find a skinCluster for input mesh " + $mesh + " -- weights were not transferred.");
      continue;
    }
    $sourceSkinCluster = $selArr[0];
  
    // Transfer weights from old skin
    print ("copySkinWeights: " + $mesh + " : " + $sourceSkinCluster + " -> " + $newMesh + " : " + $destSkinCluster + "\n");
    copySkinWeights -noMirror -sa closestComponent -ia name -ia closestBone -ss $sourceSkinCluster -ds $destSkinCluster;
  }

  // Group all originals so they're easier to get rid of (after validation)
  group -world -name "rescaleSkinnedMeshes_originals" $meshes $origSkelGroup;
}

